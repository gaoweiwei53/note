# 名词解释
字面量(Literal): a literal is a notation for representing a fixed value in source code.字面量是代码中固定值的表示，`x = 1;`中 `x`是变量(Variable), `1`是字面量。
# 虚拟机类加载机制
## 运行时数据区域
[参考](https://blog.csdn.net/xiaojin21cen/article/details/104267301)  
![运行时数据区](https://upload-images.jianshu.io/upload_images/14923529-c0cbbccaa6858ca1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  
![运行时数据区](../resources/JVM-Architecture.png)
<div style="align: center">
<img src="../resources/JVM-Architecture.png">
</div>

### 1) 程序计数器(PC)
可以看作当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
### 2) JVM Stack
每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信息。
### 3) 本地方法栈(Native Method Stack)
虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的本地方法服务。
### 4) 堆 Heap
存放对象实例，是垃圾收集器管理的内存区域。
### 5) 方法区 (Method Area)
用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
### 6) 运行时常量池 (Runtime Constant Pool)
运行时常量池是方法区的一部分。Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息常量池表(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
## 类的生命周期

### 类的加载过程
加载 --> 验证 --> 准备 --> 解析 --> 初始化
### 加载
在加载阶段虚拟机需要完成以下三件事：
1) 通过一个类的全限定名来获取定义此类的二进制字节流。
2) 将这个字节流所代表的静态存储结构转化为**方法区**的运行时数据结构。
3) 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
### 验证
验证是Linking阶段的第一步，这一步的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机的自身安全。
验证阶段大致会完成四个检验：
- 文件格式验证：验证字节流是否符合Class文件格式规范。
- 元数据验证：对类的元数据信息进行语义校验，保证不存在与《Java虚拟机规范》定义相悖的元数据信息。
- 字节码验证：
- 符号引用验证
## 准备
正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置变量初始值。从概念上讲，这些变量所使用的内存都应当在方法区中进行分配。
## 解析
解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。
- 符号引用
- 直接引用

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点 限定符这7类符合引用进行。
## 初始化
根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。也就是执行类构造器`<Clinit>()`方法的过程

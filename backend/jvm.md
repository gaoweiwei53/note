# 名词解释
字面量(Literal): a literal is a notation for representing a fixed value in source code.字面量是代码中固定值的表示，`x = 1;`中 `x`是变量(Variable), `1`是字面量。
# 虚拟机类加载机制
## 运行时数据区域
[参考1](https://blog.csdn.net/xiaojin21cen/article/details/104267301)  
[参考2](https://www.oracle.com/webfolder/technetwork/tutorials/mooc/JVM_Troubleshooting/week1/lesson1.pdf)  
[参考3](https://docs.oracle.com/javase/specs/jvms/se11/html/index.html)  
![运行时数据区](https://upload-images.jianshu.io/upload_images/14923529-c0cbbccaa6858ca1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  
![运行时数据区](../resources/JVM-Architecture.png)
<div style="align: center">
<img src="../resources/JVM-Architecture.png">
</div>

### 1) 程序计数器(PC)
可以看作当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
### 2) JVM Stack
每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信息。
### 3) 本地方法栈(Native Method Stack)
虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的本地方法服务。
### 4) 堆 Heap
存放对象实例，是垃圾收集器管理的内存区域。
### 5) 方法区 (Method Area)
用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
### 6) 运行时常量池 (Runtime Constant Pool)
运行时常量池是方法区的一部分。Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息常量池表(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
## 类的生命周期

### 类的加载过程
加载 --> 验证 --> 准备 --> 解析 --> 初始化
### 加载
在加载阶段虚拟机需要完成以下三件事：
1) 通过一个类的全限定名来获取定义此类的二进制字节流。
2) 将这个字节流所代表的静态存储结构转化为**方法区**的运行时数据结构。
3) 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
### 验证
验证是Linking阶段的第一步，这一步的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机的自身安全。
验证阶段大致会完成四个检验：
- 文件格式验证：验证字节流是否符合Class文件格式规范。
- 元数据验证：对类的元数据信息进行语义校验，保证不存在与《Java虚拟机规范》定义相悖的元数据信息。
- 字节码验证：
- 符号引用验证
## 准备
正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置变量初始值。从概念上讲，这些变量所使用的内存都应当在方法区中进行分配。
## 解析
解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。
- 符号引用
- 直接引用

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点 限定符这7类符合引用进行。
## 初始化
根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。也就是执行类构造器`<Clinit>()`方法的过程
## 类加载器
对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。
三层类加载器：启动类加载器 <-- 扩展类加载器 <-- 应用类加载器
各种类加载器之间的层次关系被称为类加载器的“双亲委派模型”
双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父加载器去完成，每一个层次的类加载器都是如此，只有当父加载器反馈自己无法完成这个加载请求时，子类加载器才尝试自己去完成。
## Java模块化系统
JDK9 引入了Java模块化系统，目标：可配置的封装隔离机制。？？？
### 模块下的类加载器
扩展类加载器被平台类加载器取代。当平台及应用程序类加载器收到类加载请求，在委派给父加载器前，要判断该类是否能够归属到某一系统模块中，如果找到，就要优先委派给负责那个模块的加载器完成加载。

启动类加载器 <-- 平台类加载器 <--> 应用类加载器
# 垃圾收集器与内存分配策略
GC对堆进行回收之前，首先确定哪些对象已死。有以下算法：
1) **引用计数算法**(Reference Counting) 基本上没人用  
在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器就减一。计数器为0的对象就不在被使用。
2) **可达性分析算法**(Reachability Analysis)  
通过一系列“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程中走过的路径称为引用链(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用。
- 强引用
- 软引用
- 弱引用
- 虚引用
## 垃圾收集算法
- 新生代
- 老年代
1) **标记清除算法**  
首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，也可以反过来。
2) **标记复制算法** 目前大多数jVM采用此算法回收新生代  
将可用的内存按容量划分为大小相等的两块，每次只使用其中的一块，当一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用的那块内存空间一次清理掉。
3) **标记整理算法** 针对老年代提出的算法  
其标记过程与标记清除算法一致，但后续不是直接对对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。

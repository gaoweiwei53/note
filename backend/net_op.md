# net

# Operating System
- [参考1](https://blog.csdn.net/qq_29677867/article/details/91038642)
- [参考2](https://www.cl.cam.ac.uk/teaching/1011/OpSystems/os1a-slides.pdf)
- [操作系统教程第5版](https://ebook.hep.com.cn/ebooks/index.html#/read?id=679399074109067264)
## 1. Processes
### 1.1 进程(Process)
线程是运行中的程序，由其**程序代码**和运行相关的**数据**所组成。一个线程被**PCB**(Process Control Block)的数据结构唯一标识.
#### 进程队列及其管理
并发系统中往往同时存在许多进程，为了便于对进程进行管理和调度，将进程通的PCB组织起来。把处于同一状态的所有进程的PCB链接起的数据结构称为**进程队列**(Process Queue)。由两种通用的队列组织方式
- 链接方式: 通过PCB中的链接指针将其链接成队列
- 索引方式：系统建立若干不同的索引表记录不同状态的进程的PCB地址

### 1.2 进程运行的基本原理(从写程序到程序运行)
- 编译 编译就是把高级语言翻译为机器语言
- 链接 由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成- -个完整的装入模块装入(装载) 
  - 静态链接 在程序运行之前，先把各个目标模块及所需库链接为一个完整的可执行程序，以后不再拆开
  - 装入时动态链接 将用户源程序编译后所得到的一组目标模块，将各目标模块装入内存时，边装入边链接的链接方式。
  - 运行时动态链接 对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接，其优点是便于修改和更新，便于实现对目标模块的共享。
- 装入 由装入程序将装入模块装入内存运行
  - 绝对装入:在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。
  - 可重定位装入：在多道程序环境下，多个目标模块的起始地址通常都是从0开始，程序中的其他地址都是相对于起始地址的，此时采用可重定位装入方式，根据内存的目前情况，将装入模块装入到内存的适当位置。
  - 动态运行时装入：也称为动态重定位，程序在内存中如果发生移动，就需要采用动态的装入方式。

进程的5种状态:**Running**, **Ready**, **Blocked/Waiting**, New, Exit
### 进程互斥算法
- Dekker’s Algorithm
- Peterson’s Algorithm
### 进程通信
- 信号通信机制(Signal):
- 共享内存(Shared memory)：在存储器种划出一块共享存储区，多个进程进行读写实现通信。
- 管道通信(Pipeline)：管道是用于连接读进程和写进程以实现它们之间通信的共享文件
- 消息队列(Message)：进程间以消息为单位交换数据
- 信号量(Semaphore)：可实现进程的同步和互斥
- 套接字(Socket)：稳定

### 1.3 线程(Thread)
#### 线程的实现方式
##### 用户级线程(User-Level Thread, ULT)：
用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责(包括线程切换)

用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。

在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。(用户级线程对用户不透明，对操作系统透明)

可以这样理解，“用户级线程” 就是“从用户视角看能看到的线程”
##### 内核级线程( Kernel-Level Thread, KLT, 又称“内核支持的线程”)：
内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。

可以这样理解，“内核级线程” 就是“从操作系统内核视角看能看到的线程”
### 1.4 Scheduling
#### 调度的三个层次:

- 高级调度(作业调度)。按一定的原则从外存上处于后备队列的作业中挑选-一个(或多个)作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB)，以使它(们)获得竞争处理机的权利。
高级调度是辅存(外存)与内存之间的调度。每个作业只调入一次，调出一-次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。
暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。
- 中级调度(内存调度)，就是要决定将哪个处于挂起状态的进程重新调入内存。
.一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。

- 低级调度(进程调度)，其主要任务是按照某种方法和策略从就绪队列中选取-一个进程，将处理机分配给它。
进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。
进程调度的频率很高，-般几十毫秒一次。
#### 4.2 低级调度的基本类型
低级调度的对象一般式线程：
- 抢占式方式(preemptive)
- 非抢占式方式(nonpreemptive)
#### 4.3 常见的调度算法
1. 先来先服务调度算法(FCFS)
2. 最短作业优先调度算法(SJF)
3. 最短剩余时间
4. 最高响应比优先
5. 优先级调度算法
6. 时间片轮转调度算法
6. 多级反馈队列调度算法

### 4.4 死锁
#### 死锁产生的必要条件
- 互斥条件 进程要求对所分配的资源进行排他性控制
- 不剥夺条件 进程所获得的资源在未使用完毕之前，只能由获得该资源的进程自己释放
- 请求与保持条件 进程每次申请它所需的一部分资源
- 环路等待资源 存在一种进程资源的循环等待链

要产生死锁，4条件缺一不可，破环其中一个即可避免死锁。
#### 处理死锁的方法
- 预防死锁
- 避免死锁
- 检测及解除死锁

## 2. Concurrency
- 临界区(Critical section): 进程内需要访问共享资源的一段代码，当另一个进程在相应的代码段中时，这段代码不能执.并发进程中与共享变量有关的程序段称为临界区
- 死锁(Deadlock): 两个或多个进程无法继续进行，因为每个进程都在等待另一个进程执行某些操作的情况
- 活锁(LiveLock): 两个或多个进程在不做任何有用工作的情况下，不断地改变它们的状态以响应其他进程的变化。
- 竞争条件(Race condition): 在这种情况下，多个线程或进程读写一个共享数据项，最终结果取决于它们执行的相对时间
- 饥饿(): 一个可运行的进程被调度程序无限地忽略的一种情况;虽然它能够前进，但它永远不会被选择。
- 信号量(Semaphore)：一种同步工具，可以解决经典同步问题
- 临界资源：共享变量所代表的资源称为临界资源。
- 管程(Monitor): 一种同步工具

### 经典同步问题
- 生产者-消费者问题
- 读者-写者问题
- 哲学家进餐问题
- 理发师问题

管程

## 3. Memory Manegement
- Frame: 一种固定长度的主存块。
- Page: 在辅助内存(如磁盘)中的固定长度的数据块。一页数据可以暂时复制到主存的一个Frame中。
- Segment: 在辅助存储器中的一种变长数据块。整个段可以临时复制到主内存的一个可用区域(段)中，或者段可以划分为页，这些页可以单独复制到主内存和分页组合)。

用户程序种的地址称为逻辑地址，逻辑地址的集合称为地址空间；内存中的地址称为物理地址，物理地址的集合称为存储空间

### 3.1 内存管理技术
#### 连续空间分配
- 固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后背作业队列中，选择适当大小的作业装入该分区，如此循环。
- 动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。这种分配方式不会预先划分内存分区，而是在进程装入内存时, 根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。
#### 不连续空间分配
- 页式存储管理
- 段式存储管理
- 段页式存储管理。

##### 页式存储管理
为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立–张页表。页表由页号和块号组成
###### 基本地址变换机构
基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。

通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。
###### 具有快表的地址变换机构
快表，又称联想寄存器(TLB) ，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。
###### 引入快表后，地址的转换过程
①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。
③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)
##### 分段存储管理方式
进程的地址空间:按照程序自身的逻辑关系划分为若千个段，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，每段从0开始编址

内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。

程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立- -张段映射表，简称“段表”

##### 分段、分页管理的对比
1. 页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理.上的需要，完全是系统行为，对用户是不可见的。段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。-一个段通常包含着一-组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。
2. 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。
3. 在分段的方法中，每次程序运行时总是把程序全部装入内存，而分页的方法则有所不同。分页的思想是程序运行时用到哪页就为哪页分配内存，没用到的页暂时保留在硬盘上。当用到这些页时再在物理地址空间中为这些页分配内存，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。
4. 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。

### 3.2 局部性原理
- 时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)
- 空间局部性:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)
### 3.3 虚拟内存
基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。
在程序执行过程中，当所访问的信息不在内存时， 由操作系统负责将所需信息从外存调入内存，然后继续执行程序。
若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。
在操作系统的管理下，在用户看来似乎有-一个比实际内存大得多的内存，这就是虚拟内存(操作系统虚拟性的一个体现，实际的物理内存大小没有变，只是在逻辑.上进行了扩充)

虚拟内存由硬件 Mememory management Unit(MMU)实现
#### 如何实现虚拟内存技术
虚拟内存的实现有以下三种方式：
- 1.请求分页存储管理
- 2.请求分段存储管理
- 3.请求段页式存储管理
> 请求分页系统建立在基本分页系统的基础上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种虚拟存储器方法。

> 主要区别：
在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存(操作系统要提供请求调页(或请求调段)功能)，然后继续执行程序。
若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存(操作系统要提供页面置换(或段置换)的功能)。
### 请求分页管理方式
#### 页表机制
与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存;如果还没调入，那么也需要知道该页面在外存中存放的位置。

当内存空间不够时，要实现“页面置换” 操作系统需要通过某些指标来决定到底换出哪个页面;有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。
####  缺页中断机构
缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此缺页中断作为中断同样要经历，诸如保护CPU环境、分析中断原因、转入缺页中断处理程序、恢复CPU环境等几个步骤。
#### 地址变换机构
请求分页存储管理与基本分页存储管理的主要区别:
在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存(操作系统要提供请求调页功能，将缺失页面从外存调入内存)，然后继续执行程序。

若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存(操作系统要提供页面置换的功能，将暂时用不到的页面换出外存)。
##### 页面置换算法
- 最佳置换算法(OPT，Optimal) :每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。
- 先进先出置换算法(FIFO) :每次选择淘汰的页面是最早进入内存的页面
- 最近最久未使用置换算法(LRU，least recently used) :每次淘汰的页面是最近最久未使用的页面
- 时钟置换算法(CLOCK)
|Technique|Description|Strengths|Weaknesses|
|:--:|:--:|:--:|:--:|
|Fixed Partitioning|在系统生成时，主存被划分为许多静态分区。一个进程可以装载到大小相等或更大的分区中。|||
|Dynamic Partitioning|分区是动态创建的，因此每个进程都被加载到与该进程大小完全相同的分区中|||
|Simple Paging|主存被分成若干大小相等的Frame。进程被分成若干大小相同、长度与Frame相同的Page。通过将进程的所有Page装入可用(不一定是连续的)Frame来加载进程|||
|Simple Segmentation|每个进程被分为若干个Segement, 通过将进程的所有Segement装入动态分区(不一定是连续的)来加载进程|||
|Virtual Memory Paging|与简单分页类似，只是不需要加载进程的所有page，需要的Nonresident page会在后来自动引入。|||
|Virtual Memory Segmentation|与简单分段类似，只是不需要加载进程的所有Segement，需要的Nonresident Segement会在后来自动引入。|||
## 5. Security
## 6. Distributed Systems

# net

# Operating System
- [参考1](https://blog.csdn.net/qq_29677867/article/details/91038642)
- [参考2](https://www.cl.cam.ac.uk/teaching/1011/OpSystems/os1a-slides.pdf)
- [Operating Systems: Internals and Design Principles-William Stallings](https://repository.dinus.ac.id/docs/ajar/Operating_System.pdf)
## 1. Processes
### 1.1 进程(Process)
线程是运行中的程序，由其**程序代码**和运行相关的**数据**所组成。一个线程被**process control block**的数据结构唯一标识.

进程的5种状态:**Running**, **Ready**, **Blocked/Waiting**, New, Exit
### 进程互斥算法
- Dekker’s Algorithm
- Peterson’s Algorithm
### 进程通信
- 共享内存：在存储器种划出一块共享存储区，多个进程进行读写实现通信。
- 管道通信：管道是用于连接读进程和写进程以实现它们之间通信的共享文件
- 消息队列：进程间以消息为单位交换数据
- 信号量：可实现进程的同步和互斥
- 套接字：稳定

### 1.2 线程(Thread)
#### 线程的实现方式
##### 用户级线程(User-Level Thread, ULT)：
用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责(包括线程切换)

用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。

在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。(用户级线程对用户不透明，对操作系统透明)

可以这样理解，“用户级线程” 就是“从用户视角看能看到的线程”
##### 内核级线程( Kernel-Level Thread, KLT, 又称“内核支持的线程”)：
内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。

可以这样理解，“内核级线程” 就是“从操作系统内核视角看能看到的线程”
## 2. Concurrency
- 临界区(Critical section): 进程内需要访问共享资源的一段代码，当另一个进程在相应的代码段中时，这段代码不能执
- 死锁(Deadlock): 两个或多个进程无法继续进行，因为每个进程都在等待另一个进程执行某些操作的情况
- 活锁(LiveLock): 两个或多个进程在不做任何有用工作的情况下，不断地改变它们的状态以响应其他进程的变化。
- 竞争条件(Race condition): 在这种情况下，多个线程或进程读写一个共享数据项，最终结果取决于它们执行的相对时间
- 饥饿(): 一个可运行的进程被调度程序无限地忽略的一种情况;虽然它能够前进，但它永远不会被选择。

### 经典同步问题
- 生产者-消费者问题
- 读者-写者问题
- 哲学家进餐问题
- 理发师问题

管程


## 3. Memory Manegement
- Frame: 一种固定长度的主存块。
- Page: 在辅助内存(如磁盘)中的固定长度的数据块。一页数据可以暂时复制到主存的一个Frame中。
- Segment: 在辅助存储器中的一种变长数据块。整个段可以临时复制到主内存的一个可用区域(段)中，或者段可以划分为页，这些页可以单独复制到主内存和分页组合)。
### 内存管理技术
|Technique|Description|Strengths|Weaknesses|
|:--:|:--:|:--:|:--:|
|Fixed Partitioning|在系统生成时，主存被划分为许多静态分区。一个进程可以装载到大小相等或更大的分区中。|||
|Dynamic Partitioning|分区是动态创建的，因此每个进程都被加载到与该进程大小完全相同的分区中|||
|Simple Paging|主存被分成若干大小相等的Frame。进程被分成若干大小相同、长度与Frame相同的Page。通过将进程的所有Page装入可用(不一定是连续的)Frame来加载进程|||
|Simple Segmentation|每个进程被分为若干个Segement, 通过将进程的所有Segement装入动态分区(不一定是连续的)来加载进程|||
|Virtual Memory Paging|与简单分页类似，只是不需要加载进程的所有page，需要的Nonresident page会在后来自动引入。|||
|Virtual Memory Segmentation|与简单分段类似，只是不需要加载进程的所有Segement，需要的Nonresident Segement会在后来自动引入。|||
## 4. Scheduling
调度的三个层次:

- 高级调度(作业调度)。按一定的原则从外存上处于后备队列的作业中挑选-一个(或多个)作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB)，以使它(们)获得竞争处理机的权利。
高级调度是辅存(外存)与内存之间的调度。每个作业只调入一次，调出一-次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。
暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。
- 中级调度(内存调度)，就是要决定将哪个处于挂起状态的进程重新调入内存。
.一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。

- 低级调度(进程调度)，其主要任务是按照某种方法和策略从就绪队列中选取-一个进程，将处理机分配给它。
进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。
进程调度的频率很高，-般几十毫秒一次。
### 进程调度的方式
- 抢占式方式
- 非抢占式方式
### 常见的调度算法
1. 先来先服务调度算法(FCFS)
2. 短作业优先调度算法(SJF)
3. 优先级调度算法
4. 时间片轮转调度算法
5. 高响应比优先度调度算法
6. 多级队列调度算法
7. 多级反馈队列调度算法
## 5. Security
## 6. Distributed Systems
